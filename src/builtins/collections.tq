// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include 'src/builtins/builtins-collections-gen.h'

namespace collections {

@export
struct SetRecord {
  // SetRecord.[[Set]]
  object: JSReceiver;

  // SetRecord.[[Size]]
  // a non-negative integer or +âˆž
  size: Number;

  // SetRecord.[[Has]]
  has: JSAny;

  // SetRecord.[[Keys]]
  keys: JSAny;
}

extern macro CodeStubAssembler::CloneFixedArray(
    FixedArrayBase, constexpr ExtractFixedArrayFlag): FixedArrayBase;

extern macro CollectionsBuiltinsAssembler::AddToSetTable(
    implicit context: Context)(OrderedHashSet, Object, String): OrderedHashSet;

@export
macro LoadKeyValuePairNoSideEffects(implicit context: Context)(o: JSAny):
    KeyValuePair labels MayHaveSideEffects {
  typeswitch (o) {
    case (a: FastJSArray): {
      const length: Smi = a.length;
      typeswitch (a.elements) {
        case (elements: FixedArray): {
          return KeyValuePair{
            key: length > 0 ? array::LoadElementOrUndefined(elements, 0) :
                              Undefined,
            value: length > 1 ? array::LoadElementOrUndefined(elements, 1) :
                                Undefined
          };
        }
        case (elements: FixedDoubleArray): {
          return KeyValuePair{
            key: length > 0 ? array::LoadElementOrUndefined(elements, 0) :
                              Undefined,
            value: length > 1 ? array::LoadElementOrUndefined(elements, 1) :
                                Undefined
          };
        }
        case (FixedArrayBase): deferred {
          unreachable;
        }
      }
    }
    case (JSAny): {
      goto MayHaveSideEffects;
    }
  }
}

@export
transitioning macro LoadKeyValuePair(implicit context: Context)(o: JSAny):
    KeyValuePair {
  try {
    return LoadKeyValuePairNoSideEffects(o) otherwise Generic;
  } label Generic {
    const o = Cast<JSReceiver>(o)
        otherwise ThrowTypeError(MessageTemplate::kIteratorValueNotAnObject, o);
    return KeyValuePair{
      key: GetProperty(o, Convert<Smi>(0)),
      value: GetProperty(o, Convert<Smi>(1))
    };
  }
}

// https://tc39.es/proposal-set-methods/#sec-getsetrecord
transitioning macro GetSetRecord(implicit context: Context)(
    obj: JSAny, methodName: constexpr string): SetRecord {
  // 1. If obj is not an Object, throw a TypeError exception.
  const obj = Cast<JSReceiver>(obj)
      otherwise ThrowTypeError(MessageTemplate::kArgumentIsNonObject, methodName);

  // 2. Let rawSize be ? Get(obj, "size").
  const rawSize = GetProperty(obj, kSizeString);

  // 3. Let numSize be ? ToNumber(rawSize).
  const numSize = ToNumber_Inline(rawSize);
  if (NumberIsNaN(numSize)) {
    // 4. NOTE: If rawSize is undefined, then numSize will be NaN.
    // 5. If numSize is NaN, throw a TypeError exception.
    ThrowTypeError(MessageTemplate::kSizeIsNaN);
  }

  // 6. Let intSize be ! ToIntegerOrInfinity(numSize).
  const intSize = ToInteger_Inline(numSize);

  // 7. Let has be ? Get(obj, "has").
  let has = GetProperty(obj, kHasString);

  // 8. If IsCallable(has) is false, throw a TypeError exception.
  has = Cast<Callable>(has)
      otherwise ThrowTypeError(MessageTemplate::kCalledNonCallable, kHasString);

  // 9. Let keys be ? Get(obj, "keys").
  let keys = GetProperty(obj, kKeysString);

  // 10. If IsCallable(keys) is false, throw a TypeError exception.
  keys = Cast<Callable>(keys)
      otherwise ThrowTypeError(MessageTemplate::kCalledNonCallable, kKeysString);

  // 11. Return a new Set Record { [[Set]]: obj, [[Size]]: intSize, [[Has]]:
  // has, [[Keys]]: keys }.
  return SetRecord{object: obj, size: intSize, has: has, keys: keys};
}

// https://tc39.es/proposal-set-methods/#sec-getkeysiterator
transitioning macro GetKeysIterator(implicit context: Context)(
    set: JSReceiver, keys: Callable): iterator::IteratorRecord {
  // 1. Let keysIter be ? Call(setRec.[[Keys]], setRec.[[Set]]).
  const keysIter = Call(context, keys, set);

  // 2. If keysIter is not an Object, throw a TypeError exception.
  const keysIterObj = Cast<JSReceiver>(keysIter)
      otherwise ThrowTypeError(MessageTemplate::kKeysMethodInvalid);

  // 3. Let nextMethod be ? Get(keysIter, "next").
  const nextMethod = GetProperty(keysIter, kNextString);

  // 4. If IsCallable(nextMethod) is false, throw a TypeError exception.
  Cast<Callable>(nextMethod)
      otherwise ThrowTypeError(MessageTemplate::kCalledNonCallable, kNextString);

  // 5. Return a new Iterator Record { [[Iterator]]: keysIter, [[NextMethod]]:
  // nextMethod, [[Done]]: false }.
  return iterator::IteratorRecord{object: keysIterObj, next: nextMethod};
}
}
