// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include 'src/builtins/builtins-promise.h'
#include 'src/builtins/builtins-promise-gen.h'

namespace promise {

  // TODO(joshualitt): The below ContextSlots are only available on synthetic
  // contexts created by the promise pipeline for use in the promise pipeline.
  // However, with Torque we should type the context and its slots to prevent
  // accidentially using these slots on contexts which don't support them.
  const kPromiseBuiltinsValueSlot: constexpr ContextSlot
  generates 'PromiseBuiltins::kValueSlot';
  const kPromiseBuiltinsOnFinallySlot: constexpr ContextSlot
  generates 'PromiseBuiltins::kOnFinallySlot';
  const kPromiseBuiltinsConstructorSlot: constexpr ContextSlot
  generates 'PromiseBuiltins::kConstructorSlot';
  const kPromiseBuiltinsPromiseValueThunkOrReasonContextLength: constexpr int31
  generates 'PromiseBuiltins::kPromiseValueThunkOrReasonContextLength';

  transitioning javascript builtin
  PromiseValueThunkFinally(js-implicit context: Context, receiver: JSAny)():
      JSAny {
    return UnsafeCast<JSAny>(context[kPromiseBuiltinsValueSlot]);
  }

  transitioning javascript builtin
  PromiseThrowerFinally(js-implicit context: Context, receiver: JSAny)():
      never {
    const reason = UnsafeCast<JSAny>(context[kPromiseBuiltinsValueSlot]);
    Throw(reason);
  }

  macro CreateThrowerFunction(implicit context: Context)(
      nativeContext: NativeContext, reason: JSAny): JSFunction {
    const throwerContext = AllocateSyntheticFunctionContext(
        nativeContext, kPromiseBuiltinsPromiseValueThunkOrReasonContextLength);
    throwerContext[kPromiseBuiltinsValueSlot] = reason;
    const map = UnsafeCast<Map>(
        nativeContext
            [NativeContextSlot::STRICT_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX]);
    const throwerInfo = UnsafeCast<SharedFunctionInfo>(
        nativeContext[NativeContextSlot::PROMISE_THROWER_FINALLY_SHARED_FUN]);
    return AllocateFunctionWithMapAndContext(map, throwerInfo, throwerContext);
  }

  extern transitioning macro
  PromiseBuiltinsAssembler::InvokeThen(NativeContext, JSAny, JSAny): JSAny;
  extern transitioning macro PromiseBuiltinsAssembler::InvokeThen(
      NativeContext, JSAny, JSAny, JSAny): JSAny;

  transitioning javascript builtin
  PromiseCatchFinally(js-implicit context: Context, receiver: JSAny)(
      reason: JSAny): JSAny {
    // 1. Let onFinally be F.[[OnFinally]].
    // 2. Assert: IsCallable(onFinally) is true.
    const onFinally =
        UnsafeCast<Callable>(context[kPromiseBuiltinsOnFinallySlot]);

    // 3. Let result be ? Call(onFinally).
    const result = Call(context, onFinally, Undefined);

    // 4. Let C be F.[[Constructor]].
    const constructor =
        UnsafeCast<JSFunction>(context[kPromiseBuiltinsConstructorSlot]);

    // 5. Assert: IsConstructor(C) is true.
    assert(IsConstructor(constructor));

    // 6. Let promise be ? PromiseResolve(C, result).
    const promise = PromiseResolve(constructor, result);

    // 7. Let thrower be equivalent to a function that throws reason.
    const nativeContext = LoadNativeContext(context);
    const thrower = CreateThrowerFunction(nativeContext, reason);

    // 8. Return ? Invoke(promise, "then", « thrower »).
    return UnsafeCast<JSAny>(InvokeThen(nativeContext, promise, thrower));
  }

}
