// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include 'src/builtins/builtins-promise-gen.h'

namespace promise {
  const kCalledOnNonObject: constexpr MessageTemplate
  generates 'MessageTemplate::kCalledOnNonObject';

  const PROMISE_PROTOTYPE_INDEX: constexpr NativeContextSlot
  generates 'Context::PROMISE_PROTOTYPE_INDEX';

  extern macro ConstructorStringConstant(): String;
  const kConstructorString: String = ConstructorStringConstant();

  // https://tc39.es/ecma262/#sec-promise.resolve
  transitioning javascript builtin
  PromiseResolveTrampoline(js-implicit context: NativeContext, receiver: JSAny)(
      value: JSAny): JSAny {
    // 1. Let C be the this value.
    // 2. If Type(C) is not Object, throw a TypeError exception.
    const receiver = Cast<JSReceiver>(receiver) otherwise
    ThrowTypeError(kCalledOnNonObject, 'PromiseResolve');

    // 3. Return ? PromiseResolve(C, x).
    return PromiseResolve(receiver, value);
  }

  transitioning builtin
  PromiseResolve(implicit context:
                     Context)(constructor: JSReceiver, value: JSAny): JSAny {
    const nativeContext = LoadNativeContext(context);
    const promiseFun = nativeContext[PROMISE_FUNCTION_INDEX];
    try {
      // Check if {value} is a JSPromise.
      const value = Cast<JSPromise>(value) otherwise NeedToAllocate;

      // We can skip the "constructor" lookup on {value} if it's [[Prototype]]
      // is the (initial) Promise.prototype and the @@species protector is
      // intact, as that guards the lookup path for "constructor" on
      // JSPromise instances which have the (initial) Promise.prototype.
      const promisePrototype = nativeContext[PROMISE_PROTOTYPE_INDEX];
      if (value.map.prototype != promisePrototype) {
        goto SlowConstructor;
      }

      if (IsPromiseSpeciesProtectorCellInvalid()) goto SlowConstructor;

      // If the {constructor} is the Promise function, we just immediately
      // return the {value} here and don't bother wrapping it into a
      // native Promise.
      if (promiseFun != constructor) goto SlowConstructor;
      return value;
    }
    label SlowConstructor deferred {
      // At this point, value or/and constructor are not native promises, but
      // they could be of the same subclass.
      const valueConstructor = GetProperty(value, kConstructorString);
      if (valueConstructor != constructor) goto NeedToAllocate;
      return value;
    }
    label NeedToAllocate deferred {
      if (promiseFun == constructor) {
        // This adds a fast path for native promises that don't need to
        // create NewPromiseCapability.
        const result = AllocateAndInitJSPromise(context);
        ResolvePromise(context, result, value);
        return result;
      } else
        deferred {
          const capability = NewPromiseCapability(constructor, True);
          const resolve = UnsafeCast<Callable>(capability.resolve);
          Call(context, resolve, Undefined, value);
          return capability.promise;
        }
    }
  }
}
