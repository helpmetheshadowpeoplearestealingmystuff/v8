--- src/graph-codegen.cc	(revision 757)
+++ src/graph-codegen.cc	(working copy)
@@ -45,6 +45,7 @@
       bailout_literals_(8),
       arguments_stack_height_(0),
       safepoint_pc_offsets_(32),
+      safepoint_bailout_ids_(32),
       safepoint_span_indexes_(32),
       current_block_(NULL),
       next_block_(NULL),
@@ -257,6 +258,7 @@
   }
 }
 
+
 SpanList* SpanList::Insert(Span* span) {
   return new SpanList(span, this);
 }
@@ -994,90 +996,9 @@
     BAILOUT("attempted bailout when deoptimization is impossible");
   }
 
-  // Compute the output frame height.
-  int height = environment_.ExpressionStackHeight();
-
-  // Build the translation.  The size is the part above the frame pointer.
-  int translation_size = height + LocalCount();
-  Translation translation(&translations_, translation_size);
-
-  // Total output frame size: Expression stack + locals + fixed elements +
-  // parameters and receiver.
-  int output_frame_size = translation_size + 4 + ParameterCount() + 1;
-
-  // The parameters are at the bottom of the frame.  They have negative
-  // span indices that increase (go toward zero) as the parameter index
-  // goes up.  They have positive destination indices that decrease as the
-  // parameter index goes up.
-  //
-  // Output frame index of the slot above the last parameter.  First '1' is
-  // receiver, second '1' is to convert to a zero-based index.
-  int parameter_base = output_frame_size - (ParameterCount() + 1) - 1;
-  EnvironmentIterator parameters(&environment_,
-                                 EnvironmentIterator::PARAMETERS);
-  while (parameters.HasNext()) {
-    Span* span = parameters.Next()->span();
-    ASSERT(span->HasFixedSpillSlot());
-    int dest_index = parameter_base - span->index();
-    if (span->IsAllocated()) {
-      translation.MoveStackReg(dest_index, span->reg());
-    } else if (span->IsSpilled()) {
-      // Nothing to do. Parameter already in its fixed slot.
-    } else {
-      UNREACHABLE();
-    }
-  }
-
-  // Setup the locals.  Locals have positive span indices that increase as
-  // the local index goes up.  They have positive output frame indices that
-  // decrease as the local index goes up.
-  int output_index = translation_size - 1;  // For local 0.
-  EnvironmentIterator locals(&environment_, EnvironmentIterator::LOCALS);
-  while (locals.HasNext()) {
-    Span* span = locals.Next()->span();
-    if (span->IsAllocated()) {
-      translation.MoveStackReg(output_index, span->reg());
-    } else if (span->IsSpilled()) {
-      // TODO(kmillikin): spilled spans should be already in place in the
-      // output frame.  Eliminate this move.
-      translation.MoveStackStack(output_index, span->index());
-    } else {
-      UNREACHABLE();
-    }
-    --output_index;
-  }
-
-  // Setup the rest of the expression stack.
-  for (int i = 0; i < height; i++) {
-    Expression* expr = environment_.ExpressionStackAt(i);
-    Span* span = expr->span();
-    if (span->IsAllocated()) {
-      translation.MoveStackReg(i, span->reg());
-    } else if (span->IsSpilled()) {
-      translation.MoveStackStack(i, span->index());
-    } else if (span->IsArgument()) {
-      int index = arguments_stack_height_ - (span->ArgumentIndex() + 1);
-      translation.MoveStackArgument(i, index);
-    } else if (expr->AsLiteral() != NULL) {
-      int index = DefineBailoutLiteral(expr->AsLiteral()->handle());
-      translation.MoveStackLiteral(i, index);
-    } else {
-      UNREACHABLE();
-    }
-  }
-
-  // Emit the bailout information.
-  int id = bailouts_.length();
-  Bailout bailout = {
-    node->id(),
-    translation.index(),
-    arguments_stack_height_,
-  };
-  bailouts_.Add(bailout);
+  unsigned id = RecordBailout(node);
   Address entry = Deoptimizer::GetDeoptimizationEntry(id);
-  if (entry == NULL) {
-    BAILOUT("bailout was not prepared");
-  }
+  if (entry == NULL) BAILOUT("too many bailouts");
   __ j(cc, entry, RelocInfo::RUNTIME_ENTRY, not_taken);
 }
 
@@ -1920,9 +1841,102 @@
   }
   safepoint_pc_offsets_.Add(masm_->pc_offset());
   safepoint_span_indexes_.Add(indexes);
+
+  // Record a bailout at every safe point.
+  unsigned id = RecordBailout(current_instruction());
+  safepoint_bailout_ids_.Add(id);
+  if (Deoptimizer::GetDeoptimizationEntry(id) == NULL) {
+    BAILOUT("too many bailouts");
+  }
 }
 
 
+unsigned GraphCodeGenerator::RecordBailout(AstNode* node) {
+  // Compute the output frame height.
+  int height = environment_.ExpressionStackHeight();
+
+  // Build the translation.  The size is the part above the frame pointer.
+  int translation_size = height + LocalCount();
+  Translation translation(&translations_, translation_size);
+
+  // Total output frame size: Expression stack + locals + fixed elements +
+  // parameters and receiver.
+  int output_frame_size = translation_size + 4 + ParameterCount() + 1;
+
+  // The parameters are at the bottom of the frame.  They have negative
+  // span indices that increase (go toward zero) as the parameter index
+  // goes up.  They have positive destination indices that decrease as the
+  // parameter index goes up.
+  //
+  // Output frame index of the slot above the last parameter.  First '1' is
+  // receiver, second '1' is to convert to a zero-based index.
+  int parameter_base = output_frame_size - (ParameterCount() + 1) - 1;
+  EnvironmentIterator parameters(&environment_,
+                                 EnvironmentIterator::PARAMETERS);
+  while (parameters.HasNext()) {
+    Span* span = parameters.Next()->span();
+    ASSERT(span->HasFixedSpillSlot());
+    int dest_index = parameter_base - span->index();
+    if (span->IsAllocated()) {
+      translation.MoveStackReg(dest_index, span->reg());
+    } else if (span->IsSpilled()) {
+      // Nothing to do. Parameter already in its fixed slot.
+    } else {
+      UNREACHABLE();
+    }
+  }
+
+  // Setup the locals.  Locals have positive span indices that increase as
+  // the local index goes up.  They have positive output frame indices that
+  // decrease as the local index goes up.
+  int output_index = translation_size - 1;  // For local 0.
+  EnvironmentIterator locals(&environment_, EnvironmentIterator::LOCALS);
+  while (locals.HasNext()) {
+    Span* span = locals.Next()->span();
+    if (span->IsAllocated()) {
+      translation.MoveStackReg(output_index, span->reg());
+    } else if (span->IsSpilled()) {
+      // TODO(kmillikin): spilled spans should be already in place in the
+      // output frame.  Eliminate this move.
+      translation.MoveStackStack(output_index, span->index());
+    } else {
+      UNREACHABLE();
+    }
+    --output_index;
+  }
+
+  // Setup the rest of the expression stack.
+  for (int i = 0; i < height; i++) {
+    Expression* expr = environment_.ExpressionStackAt(i);
+    Span* span = expr->span();
+    if (span->IsAllocated()) {
+      translation.MoveStackReg(i, span->reg());
+    } else if (span->IsSpilled()) {
+      translation.MoveStackStack(i, span->index());
+    } else if (span->IsArgument()) {
+      int index = arguments_stack_height_ - (span->ArgumentIndex() + 1);
+      translation.MoveStackArgument(i, index);
+    } else if (expr->AsLiteral() != NULL) {
+      int index = DefineBailoutLiteral(expr->AsLiteral()->handle());
+      translation.MoveStackLiteral(i, index);
+    } else {
+      UNREACHABLE();
+    }
+  }
+
+  // Emit the bailout information.
+  unsigned id = bailouts_.length();
+  Bailout bailout = {
+    node->id(),
+    translation.index(),
+    arguments_stack_height_,
+  };
+  bailouts_.Add(bailout);
+  return id;
+
+}
+
+
 unsigned GraphCodeGenerator::EmitSafepointTable(unsigned prologue_size) {
   // Make sure the safepoint table is properly aligned. Pad with nops.
   static const unsigned kTableAlignment = kIntSize;
